<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Generate level
//Room dimensions
room_width = (CELL_WIDTH / 16) * 720 * 4;
room_height = (CELL_HEIGHT / 16) * 720 * 4;
randomize();
//Grid dimensions
var width = room_width div CELL_WIDTH;
var height = room_height div CELL_HEIGHT;
//Create grid and set with void
grid = ds_grid_create(width, height);
ds_grid_set_region(grid, 0, 0, width - 1, height - 1, VOID);

//Sets the borders of grid with NO_CENTER tiles which restrict the spawn zone of center room tiles.
ds_grid_set_region(grid, 0, 0, width - 1, (MAX_ROOM_SIZE div 2) + 1, NO_CENTER); //Top layer
ds_grid_set_region(grid, 0, height - (MAX_ROOM_SIZE div 2) - 1, width - 1, height - 1, NO_CENTER); //Bottom  layer
ds_grid_set_region(grid, 0, 0, (MAX_ROOM_SIZE div 2) + 1, height - 1, NO_CENTER); //Left layer
ds_grid_set_region(grid, width - (MAX_ROOM_SIZE div 2) - 1, 0, width - 1, height - 1, NO_CENTER); //Right layer  

//Create controller
var cx = width div 2;
var cy = height div 2;
var cdir = irandom(3);

//Create player
instance_create((cx * CELL_WIDTH) + (CELL_WIDTH/2), (cy * CELL_HEIGHT) + (CELL_HEIGHT/2), obj_player);

generate_room(cx, cy, true);

var gridArea = (width - MAX_ROOM_SIZE) * (height - MAX_ROOM_SIZE);
var rooms = ROOMS;
cx = (MAX_ROOM_SIZE div 2) + 1;
cy = (MAX_ROOM_SIZE div 2) + 1;
while(rooms &gt; 0) {
    //var odds = irandom(gridArea);
    for(var yy = (MAX_ROOM_SIZE div 2) + 1;; yy &lt; height - (MAX_ROOM_SIZE div 2); yy++) {
        for(var xx = (MAX_ROOM_SIZE div 2) + 1; xx &lt; width - (MAX_ROOM_SIZE div 2); xx++) {
            var odds = irandom(gridArea);
            if(odds == 1 &amp;&amp; grid[# xx, yy] != NO_CENTER &amp;&amp; grid[# xx, yy] != FLOOR) {
                generate_room(xx, yy, false);
                rooms--;
            }
            if(rooms == 0) {
                break
            }
        }
        if(rooms == 0) {
            break;
        }
    }
}
for(var yy = 1; yy &lt; height - 1; yy++) {
    for(var xx = 1; xx &lt; width - 1; xx++) {
        if(grid[# xx, yy] == FLOOR) {
            if(grid[# xx + 1, yy] == VOID || grid[# xx + 1, yy] == NO_CENTER) {
                grid[# xx + 1, yy] = WALL;
            }
            if(grid[# xx - 1, yy] == VOID || grid[# xx - 1, yy] == NO_CENTER) {
                grid[# xx - 1, yy] = WALL;
            }
            if(grid[# xx, yy + 1] == VOID || grid[# xx, yy + 1] == NO_CENTER) {
                grid[# xx, yy + 1] = WALL;
            }
            if(grid[# xx, yy - 1] == VOID || grid[# xx, yy - 1] == NO_CENTER) {
                grid[# xx, yy - 1] = WALL;
            }
        }
    }
}

for(var yy = (MAX_ROOM_SIZE div 2) + 1;; yy &lt; height - (MAX_ROOM_SIZE div 2); yy++) {
    for(var xx = (MAX_ROOM_SIZE div 2) + 1; xx &lt; width - (MAX_ROOM_SIZE div 2); xx++) {
        if(grid[# xx, yy] == CENTER_ROOM) {
            connect_rooms(xx, yy);
            grid[# xx, yy] = NEW_CENTER;
        }
    }
 }
 
for(var yy = 1; yy &lt; height - 1; yy++) {
    for(var xx = 1; xx &lt; width - 1; xx++) {
        if(grid[# xx, yy] == FLOOR || grid[# xx, yy] == DOOR) {
            if(grid[# xx + 1, yy] == VOID || grid[# xx + 1, yy] == NO_CENTER) {
                grid[# xx + 1, yy] = WALL;
            }
            if(grid[# xx - 1, yy] == VOID || grid[# xx - 1, yy] == NO_CENTER) {
                grid[# xx - 1, yy] = WALL;
            }
            if(grid[# xx, yy + 1] == VOID || grid[# xx, yy + 1] == NO_CENTER) {
                grid[# xx, yy + 1] = WALL;
            }
            if(grid[# xx, yy - 1] == VOID || grid[# xx, yy - 1] == NO_CENTER) {
                grid[# xx, yy - 1] = WALL;
            }
        }
    }
}            
        
        
        
//Visually adds background tiles
for(var yy = 0; yy &lt; height; yy++) {
    for(var xx = 0; xx &lt; width; xx++) {
        if(grid[# xx, yy] == FLOOR) {
            tile_add(bg_floor, 0, 0, CELL_WIDTH, CELL_HEIGHT, xx * CELL_WIDTH, yy * CELL_HEIGHT, 0);
        }
        /*else if(grid[# xx, yy] == NO_CENTER) {
            tile_add(bg_noCenter, 0, 0, CELL_WIDTH, CELL_HEIGHT, xx * CELL_WIDTH, yy * CELL_HEIGHT, 0);
        }*/
        else if(grid[# xx, yy] == NEW_CENTER) {
            tile_add(bg_centerRoom, 0, 0, CELL_WIDTH, CELL_HEIGHT, xx * CELL_WIDTH, yy * CELL_HEIGHT, 0);
        }
        else if(grid[# xx, yy] == DOOR) {
            tile_add(bg_door, 0, 0, CELL_WIDTH, CELL_HEIGHT, xx * CELL_WIDTH, yy * CELL_HEIGHT, 0);
        }
    }
}      

//Wall tile code
//Get tile sizes
var tw  = CELL_WIDTH / 2;
var th = CELL_HEIGHT / 2;

//Add the tiles
for(var yy = 0; yy &lt; height * 2; yy++) {
    for(var xx = 0; xx &lt; width * 2; xx++) {
        if(grid[# xx div 2, yy div 2] == FLOOR || grid[# xx div 2, yy div 2] == DOOR) {
            //Get tile x and y position
            var tx = xx * tw;
            var ty = yy * th;
            
            var right = grid[# (xx + 1) div 2, yy div 2] != FLOOR &amp;&amp; grid[# (xx + 1) div 2, yy div 2] != DOOR &amp;&amp; grid[# (xx + 1) div 2, yy div 2] != NEW_CENTER;
            var left = grid[# (xx - 1) div 2, yy div 2] != FLOOR &amp;&amp; grid[# (xx - 1) div 2, yy div 2] != DOOR &amp;&amp; grid[# (xx - 1) div 2, yy div 2] != NEW_CENTER;
            var top = grid[# xx div 2, (yy - 1) div 2] != FLOOR &amp;&amp; grid[# xx div 2, (yy - 1) div 2] != DOOR &amp;&amp; grid[# xx div 2, (yy - 1) div 2] != NEW_CENTER;
            var bottom = grid[# xx div 2, (yy + 1) div 2] != FLOOR &amp;&amp; grid[# xx div 2, (yy + 1) div 2] != DOOR &amp;&amp; grid[# xx div 2, (yy + 1) div 2] != NEW_CENTER;
            
            var top_right = grid[# (xx + 1) div 2, (yy - 1) div 2] != FLOOR &amp;&amp; grid[# (xx + 1) div 2, (yy - 1) div 2] != DOOR &amp;&amp; grid[# (xx + 1) div 2, (yy - 1) div 2] != NEW_CENTER;
            var top_left = grid[# (xx - 1) div 2, (yy +- 1) div 2] != FLOOR &amp;&amp; grid[# (xx - 1) div 2, (yy - 1) div 2] != DOOR &amp;&amp; grid[# (xx - 1) div 2, (yy - 1) div 2] != NEW_CENTER; 
            var bottom_right = grid[# (xx + 1) div 2, (yy + 1) div 2] != FLOOR &amp;&amp; grid[# (xx + 1) div 2, (yy + 1) div 2] != DOOR &amp;&amp; grid[# (xx + 1) div 2, (yy + 1) div 2] != NEW_CENTER;
            var bottom_left = grid[# (xx - 1) div 2, (yy + 1) div 2] != FLOOR &amp;&amp; grid[# (xx - 1) div 2, (yy + 1) div 2] != DOOR &amp;&amp; grid[# (xx - 1) div 2, (yy + 1) div 2] != NEW_CENTER; 
            
            if(right) {
                if(bottom) {
                    tile_add(bg_wall, tw * 4, th * 1, tw, th, tx + tw, ty, -ty + 10);
                }
                else if(top) {
                    if(top_right) {
                        tile_add(bg_wall, tw * 4, th * 0, tw, th, tx + tw, ty - th, -ty + 10);
                    }
                    else {
                        tile_add(bg_wall, tw * 3, th * 0, tw, th, tx, ty - th, -ty + 10);
                    }
                    tile_add(bg_wall, tw * 0, th * 1, tw, th, tx + tw, ty, -ty + 10);
                }
                else {
                    tile_add(bg_wall, tw * 0, th * 1, tw, th, tx + tw, ty, -ty + 10);
                }
            }
            if(left) {
                if(bottom) {
                    tile_add(bg_wall, tw * 3, th * 1, tw, th, tx - tw, ty, -ty + 10);
                }
                else if(top) {
                    if(top_left) {
                        tile_add(bg_wall, tw * 3, th * 0, tw, th, tx - tw, ty - th, -ty + 10);
                        tile_add(bg_wall, tw * 2, th * 1, tw, th, tx - tw, ty, -ty + 10);
                    }
                    else {
                        tile_add(bg_wall, tw * 4, th * 0, tw, th, tx, ty - th, -ty + 10);
                    }
                }
                else {
                    tile_add(bg_wall, tw * 2, th * 1, tw, th, tx - tw, ty, -ty + 10);
                }
                //tile_add(bg_wall, tw * 2, th * 1, tw, th, tx - tw, ty, -ty);
            }
            if(top) {
                if(!top_right) {
                    tile_add(bg_wall, tw * 2, th * 2, tw, th, tx, ty - th, -ty + 10);
                }
                else if(!top_left) {
                    tile_add(bg_wall, tw * 0, th * 2, tw, th, tx, ty - th, -ty + 10);
                }
                else {
                    tile_add(bg_wall, tw * 1, th * 2, tw, th, tx, ty - th, -ty + 10);
                }
            }
            if(bottom) {
                if(!bottom_right) {
                    tile_add(bg_wall, tw * 2, th * 0, tw, th, tx, ty, -ty - tw);
                }
                else if(!bottom_left) {
                    tile_add(bg_wall, tw * 0, th * 0, tw, th, tx, ty, -ty - tw);
                }
                else {
                    tile_add(bg_wall, tw * 1, th * 0, tw, th, tx, ty, -ty - tw);
                }
            }
        }
    }
}    
    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="82">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>room_restart();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
